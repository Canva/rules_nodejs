"""
`node_modules` module extension implementation.
"""

load("//lib/private:repositories.bzl", "yarn_install", "yarn_install_via_action", "YARN_INSTALL_ATTRS")

visibility(["//lib/private"])

def _node_modules_impl(mctx):
    root_modules = []
    for mod in mctx.modules:
        for attrs in mod.tags.yarn:
            if mod.is_root:
                root_modules.append(attrs.name)
            yarn_install(
                name = attrs.name,
                data = attrs.data,
                environment = attrs.environment,
                exports_directories_only = attrs.exports_directories_only,
                generate_local_modules_build_files = attrs.generate_local_modules_build_files,
                included_files = attrs.included_files,
                manual_build_file_contents = attrs.manual_build_file_contents,
                package_json = attrs.package_json,
                package_path = attrs.package_path,
                timeout = attrs.timeout,
                args = attrs.args,
                frozen_lockfile = attrs.frozen_lockfile,
                use_global_yarn_cache = attrs.use_global_yarn_cache,
                yarn_lock = attrs.yarn_lock,
                host_node_bin = attrs.host_node_bin,
                host_yarn_bin = attrs.host_yarn_bin,
            )
        for attrs in mod.tags.yarn_via_action:
            if mod.is_root:
                root_modules.append(attrs.name)
            yarn_install_via_action(
                name = attrs.name,
                package_json = attrs.package_json,
                yarn_lock = attrs.yarn_lock,
                package_path = attrs.package_path,
                host_node_bin = attrs.host_node_bin,
                data = attrs.data,
                quiet = attrs.quiet,
            )

    return mctx.extension_metadata(
        root_module_direct_deps = root_modules,
        root_module_direct_dev_deps = [],
    )

node_modules = module_extension(
    implementation = _node_modules_impl,
    tag_classes = {
        "yarn": tag_class(
            attrs = dict(YARN_INSTALL_ATTRS, **{
                "name": attr.string(
                    mandatory = True,
                ),
            }),
            doc = "",
        ),
        # The Plan
        # 
        # 1. Repo rule parses package.json and yarn.lock
        # 2. Repo rule generates `BUILD.bazel` file that calls `yarn_install_via_action`
        #    This is done so that outputs go to the same directory as the `yarn_install` repo rule.
        # 3. Existing interface is preserved, work is just deferred to exec stage.
        "yarn_via_action": tag_class(
            attrs = {
                "name": attr.string(
                    mandatory = True,
                ),
                "package_json": attr.label(
                    allow_single_file = True,
                    mandatory = True,
                ),
                "yarn_lock": attr.label(
                    allow_single_file = True,
                    mandatory = True,
                ),
                "package_path": attr.string(
                    mandatory = True,
                ),
                "host_node_bin": attr.label(
                    allow_single_file = True,
                    mandatory = True,
                ),
                "data": attr.label(
                    allow_files = True,
                ),
                "quiet": attr.bool(
                    default = True,
                    doc = "Hides output, except in the event of install failure.",
                ),
            },
            doc = "",
        ),
    },
    doc = "",
)
