"""
Helper function to collect first-party packages.

Used in node rules to link the node_modules before launching a program.
This supports path re-mapping, to support short module names.
See pathMapping doc: https://github.com/Microsoft/TypeScript/issues/5039

This reads the module_root and module_name attributes from rules in
the transitive closure, rolling these up to provide a mapping to the
linker, which uses the mappings to link a node_modules directory for
runtimes to locate all the first-party packages.
"""

load("//lib/private:aspects.bzl", "MODULE_MAPPINGS_ASPECT_RESULTS_NAME")
load("//lib/private:providers.bzl", "ExternalNpmPackageInfo")
load("//lib/private:rules/nodejs_binary_test/utils/link_mapping.bzl", _link_mapping = "link_mapping")

visibility(["//lib/private"])

def _debug(vars, *args):
    if "VERBOSE_LOGS" in vars.keys():
        print("[MODULES-LINKER]", *args)

def write_node_modules_manifest(ctx, extra_data = [], mnemonic = None, link_workspace_root = False):
    """
    Writes a manifest file read by the linker, containing info about resolving runtime dependencies

    Args:
        ctx: starlark rule execution context
        extra_data: labels to search for npm packages that need to be linked (ctx.attr.deps and ctx.attr.data will always be searched)
        mnemonic: optional action mnemonic, used to differentiate module mapping files from the same rule context
        link_workspace_root: Link the workspace root to the bin_dir to support absolute requires like 'my_wksp/path/to/file'.
            If source files need to be required then they can be copied to the bin_dir with copy_to_bin.
    Returns:
        Reference to generated module mappings file.
    """

    mappings = {ctx.workspace_name: ["__link__", ctx.bin_dir.path]} if link_workspace_root else {}
    node_modules_roots = {}

    # Look through data/deps attributes to find the root directories for the third-party node_modules;
    # we'll symlink local "node_modules" to them
    for dep in extra_data + getattr(ctx.attr, "data", []) + getattr(ctx.attr, "deps", []):
        if ExternalNpmPackageInfo in dep:
            path = dep[ExternalNpmPackageInfo].path
            workspace = dep[ExternalNpmPackageInfo].workspace
            if path in node_modules_roots:
                other_workspace = node_modules_roots[path]
                if workspace != other_workspace:
                    fail("All npm dependencies at the path '%s' must come from a single workspace. Found '%s' and '%s'." % (path, other_workspace, workspace))
            node_modules_roots[path] = workspace

    # Look through data/deps attributes to find first party deps to link
    for dep in extra_data + getattr(ctx.attr, "data", []) + getattr(ctx.attr, "deps", []):
        for k, v in getattr(dep, MODULE_MAPPINGS_ASPECT_RESULTS_NAME, {}).items():
            map_key_split = k.split(":")
            package_name = map_key_split[0]
            package_path = map_key_split[1] if len(map_key_split) > 1 else ""
            if package_path not in node_modules_roots:
                node_modules_roots[package_path] = ""
            if _link_mapping(dep.label, mappings, k, v):
                _debug(ctx.var, "Linking %s: %s" % (k, v))
                mappings[k] = v

    # Write the result to a file, and use the magic node option --bazel_node_modules_manifest
    # The launcher.sh will peel off this argument and pass it to the linker rather than the program.
    prefix = ctx.label.name
    if mnemonic != None:
        prefix += "_%s" % mnemonic
    modules_manifest = ctx.actions.declare_file("_%s.module_mappings.json" % prefix)
    content = {
        "roots": node_modules_roots,
        "workspace": ctx.workspace_name,
    }
    ctx.actions.write(modules_manifest, str(content))
    return modules_manifest
